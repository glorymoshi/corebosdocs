====== coreBOS Hooks and Events ======

===== Explanation =====
TBD  FIXME


===== Types and usage =====
TBD  FIXME

==== Popup capture hook =====

The action of this hook happens when you select a record in a popup capture screen related with a uitype 10 field.

Since there are two modules participating in this event there are two ways of seeing and intercepting the event. One from the point of view of the module that is being selected and that is sending the selected field into the underlying module. This is the module that appears in the popup screen and that the user clicks on to select a record. The other point of view is that of the module receiving the selected record, the module that has the uitype 10 field and has it filled in when the user selects a record.

It would be something like these two conversations:

  * Sending Module: <wrap em>I'm in a popup screen and the user just selected one of my records. Do you want to take over and fill in the field or do you want me to do it?</wrap>
  * Receiving Module: <wrap em>Hey! One of my uitype 10 fields just got filled in. Do you want me to do some additional actions?</wrap>


=== Popup capture hook. Capture or Sending Module ====

This hook happens in the GUI on the browser in javascript when the user selects a record inside the popup screen. It launches your javascript code INSTEAD of the default javascript code to fill in the field. That means that you have to do ALL the work. Normally you will call the default function and then do some additional magic that you may require before closing the window.

The typical use case is to fill in some additional fields besides the ones that the default behavior does.

To hook into this functionality you must create a function in your module's javascript file. This function will receive three parameters:

^recordid|the crmid of the record that has been selected in the popup|
^value|the text representation of the record that has been selected in the popup|
^target_fieldname|the destination field name in the form in the browser|

Then you must add a property to your module: **popup_function** with the name of your function. That is all that is needed.

To test this functionality you can try this: add this function to Accounts.js

<code>function myspecialcapture(recordid,value,target_fieldname) {
  // first we launch the default functionality
  vtlib_setvalue_from_popup(recordid,value,target_fieldname);
  alert('This is our special intercepted capture function');
  window.close();
}</code>

Now add this property to Accounts.php: <code>var popup_function = 'myspecialcapture';</code> and go to Potentials and try to capture an Account.

=== Popup capture hook. Receiving Module ====

This hook happens in the GUI on the browser in javascript when the user selects a record inside the popup screen. It launches your javascript code AFTER having done the work of selecting the record and will permit you to add some additional functionality to the selection process.

The typical use case is to fill in some additional fields besides the ones that the default behavior does. Since the popup screen is closed and we will usually fill in the additional fields via an AJAX call, the function is executed in the browser window, not the popup screen.

To hook into this functionality you must create a function in the receiving module's javascript file with the name:

<code>{ModuleName}setValueFromCapture</code>

this function will receive the parameters:

^recordid|the crmid of the record that has been selected in the popup|
^value|the text representation of the record that has been selected in the popup|
^target_fieldname|the destination field name in the form in the browser|

To test the functionality I created this function in //Potentials.js//

<code>function PotentialssetValueFromCapture(recordid,value,target_fieldname) {
	console.log(recordid,value,target_fieldname);
	var url = "module=Accounts&action=AccountsAjax&file=Save&accountname=vtiger&dup_check=true&record=3";
	new Ajax.Request(
		'index.php',
		{
			queue: {
				position: 'end',
				scope: 'command'
			},
			method: 'post',
			postBody:url,
			onComplete: function(response) {
				var str = response.responseText;
				document.EditView.description.value = str;
			}
		}
		);

}</code>

If you add this code and then go to select an account/contact you will see that the Description field will get filled in with the message. The ajax call launched the duplicate account functionality, so depending on your install it will be an OK or a NOK message. The important thing is to see the example, I could have filled in any field with any information.


==== Related List hook =====

The need for this hook appears when a new module or functionality needs to add a related list on a module that is already installed or is a pure base module like Accounts or Contacts. To achieve this the method that will return the contents of the related list must be INSIDE the module's main class. So, for example, if we want to add a related list on Accounts, we need the method to be a native method of the Accounts class which is contained in the modules/Accounts/Accounts.php file. In other words: we need to modify a base code file.

To avoid having to do that we need a way to add the method without modifying the base code file.

Other examples are the base //get_dependents_list()// and //get_related_list()// methods. So that these methods can be executed against any module (as is currently the case) they are inside the CRMEntity class which is the base of all the entities in the system. This way, all the modules of the system inherit these methods and they can be attached easily from any other module.

We will be following the CRMEntity idea and permit adding the new method to this class. Although it would be ideal to add the new method only to the base class that needs it, that would require some additional code changes that are overly complicated and may break backward compatibility. So, in the end we will have a new method on the base CRMEntity class which all modules extend so any module will be able to use it.

The way this works is rather transparent. We [[en:devel:relatedlists|register our related list method exactly as we do with any normal related list method]]. In this case, the name of the function that defines the related list does not exist inside the function. For example, lets imagine we have this definition:

<code>$accounts->setRelatedList(Vtiger_Module::getInstance('Payslip'), 'header',Array('ADD'),'get_special_related_list');</code>

So our Payslip module is adding a related list on Accounts and wants it to call a special method called //get_special_related_list()// to obtain the contents. Now we define this method in a file inside our Payslip module. The file must be named exactly as the function name and contain exactly one function definition with that name. So we will have a file named //modules/Payslip/get_special_related_list.php// with a contents like this:

<code><?php
function get_special_related_list($param1, $param2, ..., $object) {
...
}
?>
</code>

The rest is transparent, the application know what to do. It will look for the method //get_special_related_list()//, if it isn't found it will look for the file //modules/Payslip/get_special_related_list.php//, if it is found it will load it and look for the function //get_special_related_list()//, if found it will add it as a method to the CRMEntity class and proceed with the code as usual.

There is only one small issue: due to the way PHP works adding a method dynamically at run time is really not supported. So we are forcing the code to some extent and in return we have to sacrifice that the new method will not be able to use the "$this" reference. This is why we add to the list of parameters the object reference, as can be seen in the above example.

You can find an [[https://github.com/tsolucio/corebos/blob/master/build/HelperScripts/CustomRelatedListFunction.php|example function in the helpers directory]].

With this new functionality and the [[en:devel:add_special_block|special detailed view blocks enhancements]], we can really personalize an existing module. For example, we could completely override the Project's Gantt related list with our own functionality and add a block to show the same information directly on the project's detail view, simply installing an extension module with no base code changes to the project module's code.

<WRAP center round info 80%>This enhancement is [[http://www.garfieldtech.com/blog/magical-php-call|based on this article]].  Thanks :-)</WRAP>
